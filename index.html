<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KaKaReza Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden; background: black;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }
    canvas {
      display: block;
      background: #000;
      width: 100vw;
      height: 100dvh;
      touch-action: none;
    }
    #scoreboard {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 8px 20px;
      color: white;
      font-weight: bold;
      font-size: 26px;
      letter-spacing: 2px;
      user-select: none;
      pointer-events: none;
      text-shadow:
        0 0 8px #00ff00,
        0 0 12px #00ff00,
        0 0 20px #00ff00;
      font-family: 'Orbitron', monospace;
      z-index: 10;
      min-width: 160px;
      text-align: center;
    }
  </style>
</head>
<body>

<div id="scoreboard">Score: 0 | Time: 60</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreboard = document.getElementById('scoreboard');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let W = () => canvas.width;
let H = () => canvas.height;

// Game state
let car = {
  w: W() * 0.18, // wider for easier finger tracking
  h: H() * 0.07,
  x: W() * 0.41,
  y: H() - H() * 0.15,
  speed: W() * 0.02,
  color: '#0f0',
  dragging: false,
  dragOffsetX: 0,
  opacity: 1,
};

let bullets = [];
let enemies = [];
let specialEnemies = [];
let score = 0;
let timer = 60;

let touchIdForCar = null;

// Car looks like an attack tool - spaceship style, now wider
function drawCar() {
  ctx.save();
  ctx.globalAlpha = car.opacity;
  ctx.translate(car.x + car.w / 2, car.y + car.h / 2);

  // Body
  ctx.fillStyle = car.color;
  ctx.beginPath();
  ctx.moveTo(-car.w/2, car.h/2);
  ctx.lineTo(car.w/2, car.h/2);
  ctx.lineTo(car.w/3, -car.h/2);
  ctx.lineTo(-car.w/3, -car.h/2);
  ctx.closePath();
  ctx.fill();

  // Cockpit
  ctx.fillStyle = '#0ff';
  ctx.beginPath();
  ctx.ellipse(0, -car.h/4, car.w/6, car.h/8, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
  ctx.globalAlpha = 1;
}

function drawBullets() {
  ctx.fillStyle = '#ff4040';
  bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
}

function drawEnemies() {
  enemies.forEach(e => {
    ctx.fillStyle = '#0f0'; // normal enemies - green
    ctx.fillRect(e.x, e.y, e.w, e.h);
  });
  specialEnemies.forEach(se => {
    // special enemies with bright glowing color
    let gradient = ctx.createRadialGradient(se.x + se.w / 2, se.y + se.h / 2, se.w/4, se.x + se.w / 2, se.y + se.h / 2, se.w);
    gradient.addColorStop(0, se.color);
    gradient.addColorStop(1, 'transparent');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(se.x + se.w / 2, se.y + se.h / 2, se.w / 2, 0, 2 * Math.PI);
    ctx.fill();
  });
}

// Update score board visually
function updateScoreboard() {
  scoreboard.textContent = `Score: ${score} | Time: ${timer}`;
}

function update() {
  ctx.clearRect(0, 0, W(), H());

  drawCar();
  drawBullets();
  drawEnemies();

  // Move bullets
  bullets.forEach((b, i) => {
    b.y -= H() * 0.015;
    if (b.y + b.h < 0) bullets.splice(i, 1);
  });

  // Move normal enemies
  enemies.forEach((e, i) => {
    e.y += H() * 0.005;
    if (e.y > H()) enemies.splice(i, 1);
  });

  // Move special enemies slower
  specialEnemies.forEach((se, i) => {
    se.y += H() * 0.003;
    if (se.y > H()) specialEnemies.splice(i, 1);
  });

  // Bullet hits normal enemy
  enemies.forEach((e, ei) => {
    bullets.forEach((b, bi) => {
      if (
        b.x < e.x + e.w && b.x + b.w > e.x &&
        b.y < e.y + e.h && b.y + b.h > e.y
      ) {
        enemies.splice(ei, 1);
        bullets.splice(bi, 1);
        score += 10;
      }
    });
  });

  // Bullet hits special enemy - trigger power
  specialEnemies.forEach((se, sei) => {
    bullets.forEach((b, bi) => {
      if (
        b.x < se.x + se.w && b.x + b.w > se.x &&
        b.y < se.y + se.h && b.y + b.h > se.y
      ) {
        bullets.splice(bi, 1);
        specialEnemies.splice(sei, 1);
        score += 50;
        activatePower();
      }
    });
  });

  // Keep car inside boundaries
  if (car.x < 0) car.x = 0;
  if (car.x + car.w > W()) car.x = W() - car.w;

  updateScoreboard();
}

function spawnEnemy() {
  const size = W() * 0.08;
  if (Math.random() < 0.15) {
    specialEnemies.push({
      x: Math.random() * (W() - size),
      y: -size,
      w: size,
      h: size,
      color: getRandomColor(),
    });
  } else {
    enemies.push({
      x: Math.random() * (W() - size),
      y: -size,
      w: size,
      h: size,
    });
  }
}

function shootBullet() {
  const bulletW = W() * 0.015;
  const bulletH = H() * 0.04;
  bullets.push({
    x: car.x + car.w / 2 - bulletW / 2,
    y: car.y,
    w: bulletW,
    h: bulletH
  });
}

// Powers - temporary faster shooting & color change
let powerActive = false;
let powerTimeout = null;
function activatePower() {
  if (powerActive) {
    clearTimeout(powerTimeout);
  } else {
    powerActive = true;
    car.color = '#ff0'; // bright yellow
  }
  powerTimeout = setTimeout(() => {
    powerActive = false;
    car.color = '#0f0';
  }, 8000);
}

// Touch controls with drag on car and tap to shoot anywhere else
canvas.addEventListener('touchstart', e => {
  for (let touch of e.changedTouches) {
    const tx = touch.clientX;
    const ty = touch.clientY;

    // Check if touch started on the car area (including some margin)
    if (tx >= car.x && tx <= car.x + car.w && ty >= car.y && ty <= car.y + car.h) {
      touchIdForCar = touch.identifier;
      car.dragging = true;
      car.dragOffsetX = tx - car.x;
      car.opacity = 0.7; // show translucent while dragging
    } else {
      shootBullet();
    }
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  for (let touch of e.changedTouches) {
    if (touch.identifier === touchIdForCar && car.dragging) {
      let newX = touch.clientX - car.dragOffsetX;
      // clamp inside screen
      if (newX < 0) newX = 0;
      if (newX