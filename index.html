<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KaKaReza Shooting Game</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: radial-gradient(circle, #000 40%, #111);
      font-family: Arial, sans-serif;
    }
    canvas {
      display: block;
      position: absolute;
      top: 0;
      left: 200px; /* leave room for scoreboard */
      background: transparent;
    }
    #scoreboard {
      position: fixed;
      top: 0;
      left: 0;
      width: 200px;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      color: #0f0;
      padding: 20px;
      box-sizing: border-box;
      user-select: none;
    }
    #scoreboard h3 {
      margin-top: 0;
      font-size: 20px;
      text-align: center;
      margin-bottom: 20px;
    }
    #scoreboard p {
      font-size: 18px;
      margin: 8px 0;
    }
  </style>
</head>
<body>
  <div id="scoreboard">
    <h3>KaKaReza Shooting Game</h3>
    <p>Score: <span id="score">0</span></p>
    <p>Level: <span id="level">1</span></p>
    <p>Time Left: <span id="time">30</span>s</p>
    <p>Missed: <span id="missed">0</span></p>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // Fullscreen minus scoreboard width
    function resize() {
      canvas.width = window.innerWidth - 200;
      canvas.height = window.innerHeight;
    }
    window.addEventListener("resize", resize);
    resize();

    // Tank properties (larger size)
    const tank = {
      width: 120,
      height: 60,
      x: (canvas.width - 120) / 2,
      y: canvas.height - 80,
      speed: 12
    };

    // Bullets and obstacles
    let bullets = [];
    let obstacles = [];

    // Game state
    let score = 0;
    let missed = 0;
    let level = 1;
    let firePower = 1;
    let shotsFired = 0;
    let timeLeft = 30;
    let baseObstacles = 100;
    let maxMissed = 10;
    let obstacleSpeed = 2;

    // Keyboard input tracking
    const keys = {};

    // Draw tank (bigger green rectangle)
    function drawTank() {
      ctx.fillStyle = "lime";
      ctx.fillRect(tank.x, tank.y, tank.width, tank.height);
    }

    // Fire bullets, increasing firepower after every 10 shots
    function fireBullet() {
      shotsFired++;
      if (shotsFired % 10 === 0) firePower++;

      for (let i = 0; i < firePower; i++) {
        const offset = (i - (firePower - 1) / 2) * 20;
        bullets.push({
          x: tank.x + tank.width / 2 + offset,
          y: tank.y,
          radius: 10,
          speed: 12
        });
      }
    }

    // Draw bullets
    function drawBullets() {
      ctx.fillStyle = "yellow";
      bullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Update bullet positions and remove off-screen
    function updateBullets() {
      bullets.forEach(b => {
        b.y -= b.speed;
      });
      bullets = bullets.filter(b => b.y + b.radius > 0);
    }

    // Spawn obstacles with 10% chance to be cyan (powerup)
    function spawnObstacle() {
      const color = Math.random() < 0.1 ? "cyan" : "red";
      obstacles.push({
        x: Math.random() * (canvas.width - 60) + 30,
        y: -40,
        radius: 30,
        color: color,
        speed: obstacleSpeed
      });
    }

    // Draw obstacles (larger circles)
    function drawObstacles() {
      obstacles.forEach(o => {
        ctx.fillStyle = o.color;
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.radius, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    // Update obstacle positions and remove those off-screen (count missed)
    function updateObstacles() {
      obstacles.forEach(o => {
        o.y += o.speed;
      });

      obstacles = obstacles.filter(o => {
        if (o.y - o.radius > canvas.height) {
          missed++;
          return false;
        }
        return true;
      });
    }

    // Detect collisions between bullets and obstacles
    function detectCollisions() {
      bullets.forEach((b, bi) => {
        obstacles.forEach((o, oi) => {
          const dx = b.x - o.x;
          const dy = b.y - o.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < b.radius + o.radius) {
            bullets.splice(bi, 1);
            obstacles.splice(oi, 1);
            if (o.color === "cyan") firePower++;
            score++;
          }
        });
      });
    }

    // Update scoreboard display
    function updateScoreboard() {
      document.getElementById("score").textContent = score;
      document.getElementById("level").textContent = level;
      document.getElementById("time").textContent = timeLeft;
      document.getElementById("missed").textContent = missed;
    }

    // Move tank with keyboard (left/right)
    function moveTank() {
      if (keys["ArrowLeft"] || keys["a"]) {
        tank.x -= tank.speed;
      }
      if (keys["ArrowRight"] || keys["d"]) {
        tank.x += tank.speed;
      }
      tank.x = Math.max(0, Math.min(canvas.width - tank.width, tank.x));
    }

    // Event listeners for keyboard
    window.addEventListener("keydown", e => {
      keys[e.key] = true;
    });
    window.addEventListener("keyup", e => {
      keys[e.key] = false;
    });

    // Main draw function
    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawTank();
      drawBullets();
      drawObstacles();
    }

    // Main game loop
    function gameLoop() {
      moveTank();
      updateBullets();
      updateObstacles();
      detectCollisions();
      draw();
      updateScoreboard();

      if (missed >= maxMissed) {
        alert(`Game Over! Final Score: ${score}`);
        document.location.reload();
      }
    }

    // Fire bullets repeatedly every 300ms
    setInterval(fireBullet, 300);

    // Countdown timer and level increase every second
    setInterval(() => {
      if (timeLeft > 0) {
        timeLeft--;
      } else {
        level++;
        firePower = 1;
        shotsFired = 0;
        timeLeft = 30;
        maxMissed = Math.max(1, 10 - (level - 1));
        baseObstacles = Math.floor(baseObstacles * 1.2);
        obstacleSpeed += 0.5;
      }
    }, 1000);

    // Spawn obstacles until we reach baseObstacles count
    setInterval(() => {
      if (obstacles.length < baseObstacles) spawnObstacle();
    }, 300);

    // Run the game loop at 60 FPS
    setInterval(gameLoop, 1000 / 60);
  </script>
</body>
</html>