<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>KaKaReza Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <style>
    html, body {
      margin: 0; padding: 0; height: 100%; overflow: hidden; background: black;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
    }
    canvas {
      display: block;
      background: #000;
      width: 100vw;
      height: 100dvh;
      touch-action: none;
    }
    #scoreboard {
      position: fixed;
      top: 15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.15);
      border-radius: 12px;
      padding: 8px 20px;
      color: white;
      font-weight: bold;
      font-size: 24px;
      letter-spacing: 2px;
      user-select: none;
      pointer-events: none;
      text-shadow:
        0 0 8px #00ff00,
        0 0 12px #00ff00,
        0 0 20px #00ff00;
      font-family: 'Orbitron', monospace;
      z-index: 10;
      min-width: 140px;
      text-align: center;
    }
  </style>
</head>
<body>

<div id="scoreboard">Score: 0 | Time: 60</div>
<canvas id="gameCanvas"></canvas>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const scoreboard = document.getElementById('scoreboard');

function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resizeCanvas();
window.addEventListener('resize', resizeCanvas);

let W = () => canvas.width;
let H = () => canvas.height;

// Game state
let car = {
  w: W() * 0.12,
  h: H() * 0.06,
  x: W() * 0.44,
  y: H() - H() * 0.15,
  speed: W() * 0.015,
  color: '#0f0',
};

let bullets = [];
let enemies = [];
let specialEnemies = [];
let score = 0;
let timer = 60;

let activeTouches = {}; // Track multiple touches

// Car looks like an attack tool - draw a sleek spaceship-like shape
function drawCar() {
  ctx.save();
  ctx.translate(car.x + car.w / 2, car.y + car.h / 2);

  // Body
  ctx.fillStyle = car.color;
  ctx.beginPath();
  ctx.moveTo(-car.w/2, car.h/2);
  ctx.lineTo(car.w/2, car.h/2);
  ctx.lineTo(car.w/3, -car.h/2);
  ctx.lineTo(-car.w/3, -car.h/2);
  ctx.closePath();
  ctx.fill();

  // Cockpit
  ctx.fillStyle = '#0ff';
  ctx.beginPath();
  ctx.ellipse(0, -car.h/4, car.w/6, car.h/8, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.restore();
}

function drawBullets() {
  ctx.fillStyle = '#ff4040';
  bullets.forEach(b => ctx.fillRect(b.x, b.y, b.w, b.h));
}

function drawEnemies() {
  enemies.forEach(e => {
    ctx.fillStyle = '#0f0'; // normal enemies - green
    ctx.fillRect(e.x, e.y, e.w, e.h);
  });
  specialEnemies.forEach(se => {
    // special enemies with random bright color
    ctx.fillStyle = se.color;
    ctx.beginPath();
    ctx.arc(se.x + se.w / 2, se.y + se.h / 2, se.w / 2, 0, 2 * Math.PI);
    ctx.fill();
  });
}

function drawHUD() {
  // Now handled by #scoreboard div
}

// Game loop
function update() {
  ctx.clearRect(0, 0, W(), H());

  drawCar();
  drawBullets();
  drawEnemies();

  // Move bullets
  bullets.forEach((b, i) => {
    b.y -= H() * 0.015;
    if (b.y + b.h < 0) bullets.splice(i, 1);
  });

  // Move normal enemies
  enemies.forEach((e, i) => {
    e.y += H() * 0.005;
    if (e.y > H()) enemies.splice(i, 1);
  });

  // Move special enemies (slower)
  specialEnemies.forEach((se, i) => {
    se.y += H() * 0.003;
    if (se.y > H()) specialEnemies.splice(i, 1);
  });

  // Bullet hits normal enemy
  enemies.forEach((e, ei) => {
    bullets.forEach((b, bi) => {
      if (
        b.x < e.x + e.w && b.x + b.w > e.x &&
        b.y < e.y + e.h && b.y + b.h > e.y
      ) {
        enemies.splice(ei, 1);
        bullets.splice(bi, 1);
        score += 10;
      }
    });
  });

  // Bullet hits special enemy - gives random power
  specialEnemies.forEach((se, sei) => {
    bullets.forEach((b, bi) => {
      if (
        b.x < se.x + se.w && b.x + b.w > se.x &&
        b.y < se.y + se.h && b.y + b.h > se.y
      ) {
        bullets.splice(bi, 1);
        specialEnemies.splice(sei, 1);
        score += 50;
        activatePower();
      }
    });
  });

  // Keep car inside boundaries
  if (car.x < 0) car.x = 0;
  if (car.x + car.w > W()) car.x = W() - car.w;

  // Update scoreboard
  scoreboard.textContent = `Score: ${score} | Time: ${timer}`;
}

// Spawn enemies (normal and special)
function spawnEnemy() {
  const size = W() * 0.08;
  if (Math.random() < 0.15) {
    // spawn special enemy
    specialEnemies.push({
      x: Math.random() * (W() - size),
      y: -size,
      w: size,
      h: size,
      color: getRandomColor(),
    });
  } else {
    enemies.push({
      x: Math.random() * (W() - size),
      y: -size,
      w: size,
      h: size,
    });
  }
}

// Bullet shoot function
function shootBullet() {
  const bulletW = W() * 0.015;
  const bulletH = H() * 0.04;
  bullets.push({
    x: car.x + car.w / 2 - bulletW / 2,
    y: car.y,
    w: bulletW,
    h: bulletH
  });
}

// Powers - Example: temporary faster shooting
let powerActive = false;
let powerTimeout = null;
function activatePower() {
  if (powerActive) {
    clearTimeout(powerTimeout);
  } else {
    powerActive = true;
    car.color = '#ff0'; // change car color while powered
  }
  powerTimeout = setTimeout(() => {
    powerActive = false;
    car.color = '#0f0';
  }, 8000);
}

// Touch Controls - support multi-touch: move car at bottom 25% of screen, shoot anywhere else
canvas.addEventListener('touchstart', e => {
  for (let touch of e.changedTouches) {
    activeTouches[touch.identifier] = {
      x: touch.clientX,
      y: touch.clientY
    };
    if (touch.clientY < H() * 0.75) {
      shootBullet();
    } 
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchmove', e => {
  for (let touch of e.changedTouches) {
    if (touch.clientY > H() * 0.75) {
      car.x = touch.clientX - car.w / 2;
      if (car.x < 0) car.x = 0;
      if (car.x + car.w > W()) car.x = W() - car.w;
    }
    activeTouches[touch.identifier] = {
      x: touch.clientX,
      y: touch.clientY
    };
  }
  e.preventDefault();
}, { passive: false });

canvas.addEventListener('touchend', e => {
  for (let touch of e.changedTouches) {
    delete activeTouches[touch.identifier];
  }
  e.preventDefault();
}, { passive: false });

// Keyboard controls for desktop
document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft') car.x -= car.speed;
  if (e.key === 'ArrowRight') car.x += car.speed;
  if (e.key === ' ') shootBullet();
});

// Spawn enemies and game timer
setInterval(update, 1000 / 60);
setInterval(spawnEnemy, 900);
setInterval(() => {
  timer--;
  if (timer <= 0) {
    alert(`Time's up! Your score: ${score}`);
    timer = 60;
    score = 0;
    enemies = [];
    specialEnemies = [];
    bullets = [];
  }
}, 1000);

// Utility: random bright colors for special enemies
function getRandomColor() {
  const colors = ['#ff4500', '#1e90ff', '#ff69b4', '#00ffff', '#ffa500'];
  return colors[Math.floor(Math.random() * colors.length)];
}
</script>
</body>
</html>