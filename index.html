<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>KaKaReza Shooting Game</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; background: radial-gradient(circle, #000 40%, #111); }
    #scoreboard {
      position: absolute;
      top: 0;
      left: 0;
      width: 200px;
      height: 100%;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      font-family: Arial, sans-serif;
      padding: 10px;
      box-sizing: border-box;
      z-index: 10;
    }
  </style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="scoreboard">
  <h3>KaKaReza Shooting Game</h3>
  <p>Score: <span id="score">0</span></p>
  <p>Level: <span id="level">1</span></p>
  <p>Time Left: <span id="time">30</span>s</p>
  <p>Missed: <span id="missed">0</span></p>
</div>

<script>
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let tank = { x: canvas.width / 2 - 60, y: canvas.height - 100, width: 120, height: 60 };
let bullets = [];
let obstacles = [];
let score = 0, missed = 0, level = 1, firePower = 1, shotsFired = 0;
let timeLeft = 30, baseObstacles = 100, maxMissed = 10, obstacleSpeed = 2;
let keys = {};

function drawTank() {
  ctx.fillStyle = "lime";
  ctx.fillRect(tank.x, tank.y, tank.width, tank.height);
}

function fireBullet() {
  shotsFired++;
  if (shotsFired % 10 === 0) firePower++;
  for (let i = 0; i < firePower; i++) {
    bullets.push({
      x: tank.x + tank.width / 2 + (i - (firePower - 1) / 2) * 16,
      y: tank.y,
      radius: 8
    });
  }
}

function drawBullets() {
  ctx.fillStyle = "yellow";
  bullets.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function updateBullets() {
  bullets.forEach(b => b.y -= 10);
  bullets = bullets.filter(b => b.y > 0);
}

function spawnObstacle() {
  const color = Math.random() < 0.1 ? "cyan" : "red";
  obstacles.push({
    x: Math.random() * (canvas.width - 60) + 30,
    y: -30,
    radius: 30,
    color: color
  });
}

function drawObstacles() {
  obstacles.forEach(o => {
    ctx.fillStyle = o.color;
    ctx.beginPath();
    ctx.arc(o.x, o.y, o.radius, 0, Math.PI * 2);
    ctx.fill();
  });
}

function updateObstacles() {
  obstacles.forEach(o => o.y += obstacleSpeed);
  obstacles = obstacles.filter(o => {
    if (o.y > canvas.height) {
      missed++;
      return false;
    }
    return true;
  });
}

function detectCollisions() {
  bullets.forEach((b, bi) => {
    obstacles.forEach((o, oi) => {
      const dx = b.x - o.x;
      const dy = b.y - o.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < b.radius + o.radius) {
        bullets.splice(bi, 1);
        obstacles.splice(oi, 1);
        if (o.color === "cyan") firePower++;
        score++;
      }
    });
  });
}

function updateScoreboard() {
  document.getElementById("score").textContent = score;
  document.getElementById("level").textContent = level;
  document.getElementById("time").textContent = timeLeft;
  document.getElementById("missed").textContent = missed;
}

function moveTank() {
  if (keys["ArrowLeft"] || keys["a"]) tank.x -= 10;
  if (keys["ArrowRight"] || keys["d"]) tank.x += 10;
  tank.x = Math.max(0, Math.min(canvas.width - tank.width, tank.x));
}

window.addEventListener("keydown", e => keys[e.key] = true);
window.addEventListener("keyup", e => keys[e.key] = false);

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawTank();
  drawBullets();
  drawObstacles();
}

function gameLoop() {
  moveTank();
  updateBullets();
  updateObstacles();
  detectCollisions();
  draw();
  updateScoreboard();
  if (missed >= maxMissed) {
    alert("Game Over! Final Score: " + score);
    document.location.reload();
  }
}

setInterval(fireBullet, 300);
setInterval(() => {
  if (timeLeft > 0) {
    timeLeft--;
  } else {
    level++;
    firePower = 1;
    timeLeft = 30;
    maxMissed = Math.max(1, 10 - (level - 1));
    baseObstacles = Math.floor(baseObstacles * 1.2);
    obstacleSpeed += 0.5;
  }
}, 1000);

setInterval(() => {
  if (obstacles.length < baseObstacles) spawnObstacle();
}, 300);

setInterval(gameLoop, 1000 / 60);
</script>
</body>
</html>