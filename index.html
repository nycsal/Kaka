<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>KaKaReza Shooting Game â€“ Feature Build</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { overflow:hidden; background:#000; font-family:Arial,sans-serif; }
    #scoreboard {
      position:fixed; top:0; left:0;
      width:100%; height:80px;
      background:rgba(0,0,0,0.9);
      color:#0f0;
      display:flex; align-items:center; justify-content:space-around;
      font-size:18px; user-select:none;
    }
    #scoreboard h3 { margin:0; font-size:24px; }
    canvas { position:absolute; top:80px; left:0; touch-action:none; }
  </style>
</head>
<body>
  <div id="scoreboard">
    <h3>KaKaReza Shooting Game</h3>
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Time: <span id="time">30</span>s</div>
    <div>Missed: <span id="missed">0</span></div>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
  // --- SETUP & RESIZE ---
  const canvas = document.getElementById('gameCanvas');
  const ctx    = canvas.getContext('2d');
  const HEADER = 80;
  function resize(){
    canvas.width  = window.innerWidth;
    canvas.height = window.innerHeight - HEADER;
    tank.y = canvas.height - tank.h - 20;
  }
  window.addEventListener('resize', resize);

  // --- STARFIELD BACKGROUND ---
  const stars = [];
  for(let i=0;i<100;i++){
    stars.push({
      x: Math.random()*window.innerWidth,
      y: Math.random()*(window.innerHeight-HEADER),
      r: Math.random()*1.5+0.5,
      alpha: Math.random()*0.5+0.2,
      d: Math.random()*0.02+0.003
    });
  }
  function drawStars(){
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    stars.forEach(s=>{
      ctx.globalAlpha = s.alpha;
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r,0,Math.PI*2);
      ctx.fill();
      s.alpha += s.d;
      if(s.alpha<=0.2||s.alpha>=0.8) s.d *= -1;
    });
    ctx.globalAlpha = 1;
  }

  // --- GAME STATE ---
  const tank = { w:140, h:70, x:0, y:0, speed:12 };
  tank.x = (window.innerWidth - tank.w)/2;
  let bullets     = [],
      obstacles   = [],
      particles   = [],
      boss        = null;

  let score        = 0,
      missed       = 0,
      level        = 1,
      firePower    = 1,
      shotsFired   = 0,
      timeLeft     = 30,
      baseObstacles= 200,
      maxMissed    = 10,
      obstacleSpeed= 2;

  // --- INPUT ---
  const keys = {};
  document.addEventListener('keydown', e=>{
    if(['ArrowLeft','ArrowRight','a','d'].includes(e.key)){
      keys[e.key]=true; e.preventDefault();
    }
  });
  document.addEventListener('keyup', e=>{
    if(['ArrowLeft','ArrowRight','a','d'].includes(e.key)){
      keys[e.key]=false; e.preventDefault();
    }
  });
  let dragging=false;
  canvas.addEventListener('pointerdown', e=>{ dragging=true; updateTank(e); });
  document.addEventListener('pointerup', ()=>dragging=false);
  canvas.addEventListener('pointermove', e=>{ if(dragging) updateTank(e); });
  function updateTank(e){
    const rect = canvas.getBoundingClientRect();
    let x = e.clientX - rect.left;
    tank.x = Math.max(0, Math.min(canvas.width - tank.w, x - tank.w/2));
  }

  // --- DRAW HELPERS ---
  function drawTank(){
    ctx.fillStyle='lime';
    ctx.fillRect(tank.x, tank.y, tank.w, tank.h);
  }
  function drawBullets(){
    ctx.fillStyle='yellow';
    bullets.forEach(b=>{
      ctx.beginPath();
      ctx.arc(b.x,b.y,b.r,0,Math.PI*2);
      ctx.fill();
    });
  }
  function drawObstacles(){
    obstacles.forEach(o=>{
      ctx.fillStyle=o.color;
      ctx.beginPath();
      ctx.arc(o.x,o.y,o.r,0,Math.PI*2);
      ctx.fill();
    });
  }
  function drawBoss(){
    if(!boss) return;
    // simple tank shape for boss:
    const b = boss;
    ctx.fillStyle = 'orange';
    // body
    ctx.fillRect(b.x - b.w/2, b.y - b.h/2, b.w, b.h);
    // turret
    ctx.fillRect(b.x - 10, b.y - b.h/2 - 20, 20, 20);
  }
  function drawParticles(){
    particles.forEach((p,i)=>{
      ctx.globalAlpha = p.life/p.maxLife;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x,p.y,p.size,0,Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
      p.x += p.vx; p.y += p.vy; p.life--;
      if(p.life<=0) particles.splice(i,1);
    });
  }
  function updateScoreboard(){
    document.getElementById('score').textContent  = score;
    document.getElementById('level').textContent  = level;
    document.getElementById('time').textContent   = timeLeft;
    document.getElementById('missed').textContent = missed;
  }

  // --- CORE LOGIC ---
  function moveTank(){
    if(keys['ArrowLeft']||keys['a'])   tank.x-=tank.speed;
    if(keys['ArrowRight']||keys['d'])  tank.x+=tank.speed;
    tank.x = Math.max(0, Math.min(canvas.width - tank.w, tank.x));
  }

  function fireBullet(){
    shotsFired++;
    if(shotsFired%10===0 && firePower<3) firePower++;
    for(let i=0;i<firePower;i++){
      const off = (i-(firePower-1)/2)*22;
      bullets.push({ x:tank.x+tank.w/2+off, y:tank.y, r:10, speed:14 });
    }
  }

  function updateBullets(){
    bullets = bullets.filter(b=>{
      b.y -= b.speed;
      return b.y + b.r > 0;
    });
  }

  function spawnObstacle(){
    if(level===3 && boss) return;
    const color = Math.random()<0.1?'cyan':'red';
    const baseR = 30*0.75 * Math.pow(0.85, level-1); // extra 25% smaller
    obstacles.push({
      x: Math.random()*(canvas.width-60)+30,
      y: -baseR*1.5,
      r: baseR,
      color,
      speed: obstacleSpeed
    });
  }

  function updateObstacles(){
    obstacles = obstacles.filter(o=>{
      o.y += o.speed;
      // tank collision
      if(o.y+ o.r >= tank.y && o.x>tank.x && o.x<tank.x+tank.w){
        spawnImpact(tank.x+tank.w/2, tank.y+tank.h/2, 'orange', 24);
        resetLevel(false);
        return false;
      }
      if(o.y - o.r > canvas.height){
        missed++;
        return false;
      }
      return true;
    });
  }

  function detectCollisions(){
    for(let bi=bullets.length-1; bi>=0; bi--){
      const b = bullets[bi];
      // boss hit?
      if(boss && Math.hypot(b.x-boss.x,b.y-boss.y) < b.r+boss.r){
        bullets.splice(bi,1);
        boss.hp--;
        spawnImpact(boss.x,boss.y,'white',20);
        continue;
      }
      for(let oi=obstacles.length-1; oi>=0; oi--){
        const o = obstacles[oi];
        if(Math.hypot(b.x-o.x,b.y-o.y) < b.r+o.r){
          bullets.splice(bi,1);
          obstacles.splice(oi,1);
          spawnImpact(o.x,o.y,o.color,18);
          if(o.color==='cyan' && firePower<3) firePower++;
          score++;
          break;
        }
      }
    }
  }

  function spawnImpact(x,y,color,maxSize){
    for(let i=0;i<16;i++){
      const ang = Math.random()*Math.PI*2;
      particles.push({
        x,y,
        vx:Math.cos(ang)*(3+Math.random()*3),
        vy:Math.sin(ang)*(3+Math.random()*3),
        size:Math.random()*maxSize/4+2,
        color,
        life:20+Math.random()*15,
        maxLife:20
      });
    }
  }

  // --- BOSS LOGIC ---
  function ensureBoss(){
    if(level===3 && !boss){
      boss = { x:canvas.width/2, y:100, w:160, h:80, r:40,
               speedX:5, hp:200, fireTimer:0 };
    }
  }
  function updateBoss(){
    if(!boss) return;
    boss.x += boss.speedX;
    if(boss.x-boss.w/2<0||boss.x+boss.w/2>canvas.width) boss.speedX*=-1;
    if(++boss.fireTimer>30){
      boss.fireTimer=0;
      // boss fires 5 shots downward in a spread
      [-40,-20,0,20,40].forEach(off=>{
        obstacles.push({
          x: boss.x+off,
          y: boss.y+boss.h/2,
          r:12, color:'magenta', speed:10, isBossShot:true
        });
      });
    }
    drawBoss();
    if(boss.hp<=0){
      boss=null;
      level=4;
      resetLevel(true);
    }
  }

  function resetLevel(nextLevel){
    bullets=[]; obstacles=[]; particles=[];
    shotsFired=0; firePower=1;
    timeLeft=30; missed=0;
    if(nextLevel){
      baseObstacles = Math.floor(baseObstacles*1.2);
      obstacleSpeed += 0.5;
    }
  }

  // --- MAIN LOOP ---
  function loop(){
    moveTank();
    updateBullets();
    updateObstacles();
    detectCollisions();
    ensureBoss();

    drawStars();
    drawTank();
    drawBullets();
    drawObstacles();
    updateBoss();
    drawParticles();
    updateScoreboard();

    if(missed>=maxMissed){
      alert(`Game Over! Score: ${score}`);
      return location.reload();
    }
    requestAnimationFrame(loop);
  }

  // --- TIMERS ---
  setInterval(fireBullet,300);
  setInterval(()=>{
    if(timeLeft>0) timeLeft--;
    else {
      level++;
      resetLevel(true);
    }
  },1000);
  setInterval(()=>{
    if(obstacles.length<baseObstacles) spawnObstacle();
  },300);

  // --- START ---
  resize();
  loop();

  </script>
</body>
</html>