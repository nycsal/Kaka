<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>KaKaReza Shooting Game</title>
  <style>
    /* Full-screen canvas with fixed sidebar */
    body { margin: 0; overflow: hidden; background: #000; }
    #scoreboard {
      position: fixed; top: 0; left: 0;
      width: 200px; height: 100vh;
      background: rgba(0,0,0,0.85); color: #0f0;
      padding: 20px; box-sizing: border-box;
      user-select: none; font-family: Arial, sans-serif;
    }
    #scoreboard h3 { margin: 0 0 20px; font-size: 20px; text-align: center; }
    #scoreboard p { margin: 8px 0; font-size: 18px; }
    canvas {
      position: absolute; top: 0; left: 200px;
      background: radial-gradient(circle, #111 20%, #000);
    }
  </style>
</head>
<body>
  <div id="scoreboard">
    <h3>KaKaReza Shooting Game</h3>
    <p>Score: <span id="score">0</span></p>
    <p>Level: <span id="level">1</span></p>
    <p>Time Left: <span id="time">30</span>s</p>
    <p>Missed: <span id="missed">0</span></p>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    // ----- SETUP -----
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const sidebarWidth = 200;

    function resize() {
      canvas.width = window.innerWidth - sidebarWidth;
      canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // ----- GAME STATE -----
    const tank = {
      w: 120, h: 60,
      x: (canvas.width - 120)/2,
      y: canvas.height - 80,
      speed: 10
    };
    let bullets = [], obstacles = [];
    let score = 0, missed = 0, level = 1;
    let firePower = 1, shotsFired = 0;
    let timeLeft = 30, baseObstacles = 100, maxMissed = 10, obstacleSpeed = 2;
    const keys = {};

    // ----- INPUT -----
    document.addEventListener('keydown', e => {
      if (['ArrowLeft','ArrowRight','a','d'].includes(e.key)) {
        e.preventDefault(); // stop page scroll
        keys[e.key] = true;
      }
    });
    document.addEventListener('keyup', e => {
      if (['ArrowLeft','ArrowRight','a','d'].includes(e.key)) {
        keys[e.key] = false;
      }
    });

    // ----- DRAW FUNCTIONS -----
    function drawTank() {
      ctx.fillStyle = 'lime';
      ctx.fillRect(tank.x, tank.y, tank.w, tank.h);
    }
    function drawBullets() {
      ctx.fillStyle = 'yellow';
      bullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function drawObstacles() {
      obstacles.forEach(o => {
        ctx.fillStyle = o.color;
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function updateScoreboard() {
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('time').textContent = timeLeft;
      document.getElementById('missed').textContent = missed;
    }

    // ----- GAME LOGIC -----
    function moveTank() {
      if (keys['ArrowLeft'] || keys['a']) tank.x -= tank.speed;
      if (keys['ArrowRight'] || keys['d']) tank.x += tank.speed;
      // constrain
      tank.x = Math.max(0, Math.min(canvas.width - tank.w, tank.x));
    }

    function fireBullet() {
      shotsFired++;
      if (shotsFired % 10 === 0) firePower++;
      for (let i=0; i<firePower; i++) {
        const offset = (i - (firePower-1)/2) * 20;
        bullets.push({ x: tank.x + tank.w/2 + offset, y: tank.y, r: 10, speed: 12 });
      }
    }

    function updateBullets() {
      bullets.forEach(b => b.y -= b.speed);
      bullets = bullets.filter(b => b.y + b.r > 0);
    }

    function spawnObstacle() {
      const color = Math.random() < 0.1 ? 'cyan' : 'red';
      obstacles.push({
        x: Math.random()*(canvas.width-60)+30,
        y: -40, r: 30, color,
        speed: obstacleSpeed
      });
    }

    function updateObstacles() {
      obstacles.forEach(o => o.y += o.speed);
      obstacles = obstacles.filter(o => {
        if (o.y - o.r > canvas.height) {
          missed++;
          return false;
        }
        return true;
      });
    }

    function detectCollisions() {
      bullets.forEach((b, bi) => {
        obstacles.forEach((o, oi) => {
          const dx = b.x - o.x, dy = b.y - o.y;
          if (Math.hypot(dx, dy) < b.r + o.r) {
            bullets.splice(bi,1);
            obstacles.splice(oi,1);
            if (o.color==='cyan') firePower++;
            score++;
          }
        });
      });
    }

    // ----- MAIN LOOP -----
    function loop() {
      // move and update
      moveTank();
      updateBullets();
      updateObstacles();
      detectCollisions();

      // draw
      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawTank();
      drawBullets();
      drawObstacles();
      updateScoreboard();

      // check game over
      if (missed >= maxMissed) {
        alert(`Game Over! Final Score: ${score}`);
        return location.reload();
      }
      requestAnimationFrame(loop);
    }

    // ----- TIMERS -----
    setInterval(fireBullet, 300);
    setInterval(() => {
      if (timeLeft > 0) {
        timeLeft--;
      } else {
        level++;
        firePower = 1;
        shotsFired = 0;
        timeLeft = 30;
        maxMissed = Math.max(1, 10 - (level-1));
        baseObstacles = Math.floor(baseObstacles * 1.2);
        obstacleSpeed += 0.5;
      }
    }, 1000);
    setInterval(() => {
      if (obstacles.length < baseObstacles) spawnObstacle();
    }, 300);

    // start!
    requestAnimationFrame(loop);
  </script>
</body>
</html>