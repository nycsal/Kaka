<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>KaKaReza Shooting Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { overflow: hidden; background: #000; font-family: Arial, sans-serif; }
    /* Top scoreboard bar */
    #scoreboard {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 80px;
      background: rgba(0,0,0,0.9);
      color: #0f0;
      display: flex;
      align-items: center;
      justify-content: space-around;
      user-select: none;
      font-size: 18px;
    }
    #scoreboard h3 { margin: 0; font-size: 24px; }
    /* Game canvas below the scoreboard */
    canvas {
      position: absolute;
      top: 80px; left: 0;
      background: #000;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="scoreboard">
    <h3>KaKaReza Shooting Game</h3>
    <div>Score: <span id="score">0</span></div>
    <div>Level: <span id="level">1</span></div>
    <div>Time: <span id="time">30</span>s</div>
    <div>Missed: <span id="missed">0</span></div>
  </div>
  <canvas id="gameCanvas"></canvas>

  <script>
    // — Setup & Resize —
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const HEADER = 80;
    function resize() {
      canvas.width  = window.innerWidth;
      canvas.height = window.innerHeight - HEADER;
      tank.y = canvas.height - tank.h - 20;
    }
    window.addEventListener('resize', resize);

    // — Game State —
    const tank = { w: 140, h: 70, x: 0, y: 0, speed: 12 };
    tank.x = (window.innerWidth - tank.w) / 2;
    let bullets = [], obstacles = [];
    let score=0, missed=0, level=1;
    let firePower=1, shotsFired=0;
    let timeLeft=30, baseObstacles=200, maxMissed=10, obstacleSpeed=2;

    // — Input Tracking —
    const keys = {};
    document.addEventListener('keydown', e => {
      if (['ArrowLeft','ArrowRight','a','d'].includes(e.key)) {
        keys[e.key] = true;
        e.preventDefault();
      }
    });
    document.addEventListener('keyup', e => {
      if (['ArrowLeft','ArrowRight','a','d'].includes(e.key)) {
        keys[e.key] = false;
        e.preventDefault();
      }
    });
    // Pointer drag for touch/desktop
    let dragging = false;
    canvas.addEventListener('pointerdown', e => { dragging = true; updateTank(e); });
    document.addEventListener('pointerup', () => dragging = false);
    canvas.addEventListener('pointermove', e => { if (dragging) updateTank(e); });
    function updateTank(e) {
      const rect = canvas.getBoundingClientRect();
      let x = e.clientX - rect.left;
      tank.x = Math.max(0, Math.min(canvas.width - tank.w, x - tank.w/2));
    }

    // — Draw Helpers —
    function drawTank() {
      ctx.fillStyle = 'lime';
      ctx.fillRect(tank.x, tank.y, tank.w, tank.h);
    }
    function drawBullets() {
      ctx.fillStyle = 'yellow';
      bullets.forEach(b => {
        ctx.beginPath();
        ctx.arc(b.x, b.y, b.r, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function drawObstacles() {
      obstacles.forEach(o => {
        ctx.fillStyle = o.color;
        ctx.beginPath();
        ctx.arc(o.x, o.y, o.r, 0, Math.PI*2);
        ctx.fill();
      });
    }
    function updateScoreboard() {
      document.getElementById('score').textContent = score;
      document.getElementById('level').textContent = level;
      document.getElementById('time').textContent = timeLeft;
      document.getElementById('missed').textContent = missed;
    }

    // — Core Logic —
    function moveTank() {
      if (keys['ArrowLeft']||keys['a'])   tank.x -= tank.speed;
      if (keys['ArrowRight']||keys['d'])  tank.x += tank.speed;
      tank.x = Math.max(0, Math.min(canvas.width - tank.w, tank.x));
    }

    function fireBullet() {
      shotsFired++;
      if (shotsFired % 10 === 0 && firePower < 4) firePower++;
      for (let i = 0; i < firePower; i++) {
        const offset = (i - (firePower-1)/2) * 22;
        bullets.push({
          x: tank.x + tank.w/2 + offset,
          y: tank.y,
          r: 10,
          speed: 14
        });
      }
    }

    function updateBullets() {
      bullets = bullets.filter(b => {
        b.y -= b.speed;
        return b.y + b.r > 0;
      });
    }

    function spawnObstacle() {
      const color = Math.random() < 0.1 ? 'cyan' : 'red';
      obstacles.push({
        x: Math.random()*(canvas.width-60)+30,
        y: -50, r: 30, color, speed: obstacleSpeed
      });
    }

    function updateObstacles() {
      obstacles = obstacles.filter(o => {
        o.y += o.speed;
        if (o.y - o.r > canvas.height) {
          missed++;
          return false;
        }
        return true;
      });
    }

    function detectCollisions() {
      for (let bi = bullets.length-1; bi >= 0; bi--) {
        for (let oi = obstacles.length-1; oi >= 0; oi--) {
          const b = bullets[bi], o = obstacles[oi];
          if (Math.hypot(b.x-o.x, b.y-o.y) < b.r + o.r) {
            bullets.splice(bi,1);
            obstacles.splice(oi,1);
            if (o.color === 'cyan' && firePower < 4) firePower++;
            score++;
            break;
          }
        }
      }
    }

    // — Main Loop —
    function loop() {
      moveTank();
      updateBullets();
      updateObstacles();
      detectCollisions();

      ctx.clearRect(0,0,canvas.width,canvas.height);
      drawTank();
      drawBullets();
      drawObstacles();
      updateScoreboard();

      if (missed >= maxMissed) {
        alert(`Game Over! Score: ${score}`);
        return location.reload();
      }
      requestAnimationFrame(loop);
    }

    // — Timers & Level Logic —
    setInterval(fireBullet, 300);
    setInterval(() => {
      if (timeLeft > 0) timeLeft--;
      else {
        level++;
        firePower = 1;
        shotsFired = 0;
        timeLeft = 30;
        maxMissed = Math.max(1, 10 - (level - 1));
        baseObstacles = Math.floor(baseObstacles * 1.2);
        obstacleSpeed += 0.5;
      }
    }, 1000);
    setInterval(() => {
      if (obstacles.length < baseObstacles) spawnObstacle();
    }, 300);

    // — Start Game —
    resize();
    loop();
  </script>
</body>
</html>